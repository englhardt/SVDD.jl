<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SMO · SVDD Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SVDD Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../start/">Getting Started</a></li><li><a class="toctext" href="../svdd/">SVDD</a></li><li><span class="toctext">Custom Solvers</span><ul><li class="current"><a class="toctext" href>SMO</a><ul class="internal"><li><a class="toctext" href="#SVDD-Overview-1">SVDD Overview</a></li><li><a class="toctext" href="#SMO-for-SVDD-1">SMO for SVDD</a></li><li><a class="toctext" href="#External-API-1">External API</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Custom Solvers</li><li><a href>SMO</a></li></ul><a class="edit-page" href="https://github.com/englhardt/SVDD.jl/blob/master/docs/src/smo.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>SMO</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="smo_doc-1" href="#smo_doc-1">SMO</a></h1><p>Sequential Minimal Optimization (SMO) is a decomposition method to solve quadratic optimization problems with a specific structure. The original SMO algorithm by John C. Platt has been proposed for Support Vector Machines (SVM). There are several modifications for other types of support vector machines. This section describes the implementation of SMO for Support Vector Data Description (SVDD) [2].</p><p>The implementation of SMO for SVDD bases on an adaption of SMO for one-class classification [3]. Therefore, this documentation focuses on the specific adaptions required for SVDD. The following descriptions assume familarity with the basics of SMO [1] and its adaption to one-class SVM [3], and of SVDD [2].</p><h2><a class="nav-anchor" id="SVDD-Overview-1" href="#SVDD-Overview-1">SVDD Overview</a></h2><p>SVDD is an optimization problem of the following form.</p><div>\[  \begin{aligned}
  P: \ &amp; \underset{R, a, \xi}{\text{minimize}}
  &amp; &amp; R^2 + \sum_i \xi_i  \\
  &amp; \text{subject to}
  &amp; &amp; \left\Vert \Phi(x_{i}) - a \right\Vert^2 \leq R^2 + \xi_i, \; ∀ i \\
  &amp; &amp; &amp; \xi_i \geq 0, \; ∀ i
  \end{aligned}\]</div><p>with radius <span>$R$</span> and center of the hypershpere <span>$a$</span>, a slack variable <span>$\xi$</span>, and a mapping into an implicit feature space <span>$\Phi$</span></p><p>The Lagrangian Dual is:</p><div>\[\begin{aligned}
D: \ &amp; \underset{\alpha}{\text{maximize}}
&amp; &amp; \sum_i \alpha_iK_{i,i} - \sum_{i,j}\alpha_i\alpha_j K_{i,j} \\
&amp; \text{subject to}
&amp; &amp; \sum_i \alpha_i = 1 \\
&amp; &amp; &amp; 0 \leq \alpha_i \leq C, \; ∀ i \\
\end{aligned}\]</div><p>where <span>$\alpha$</span> are the Lagrange multipliers, and <span>$K_{i,j} = \langle {\Phi(x_i),\Phi{x_j}} \rangle$</span> the inner product in the implicit feature space. Solving the Lagrangian gives an optimal <span>$α$</span>.</p><h2><a class="nav-anchor" id="SMO-for-SVDD-1" href="#SMO-for-SVDD-1">SMO for SVDD</a></h2><p>The basic idea of SMO is to solve reduced versions of the Lagrangian iteratively. In each iteration, the reduced version of the Lagrangian consists of only two decision variables, i.e., <span>$\alpha_{i1}$</span> and <span>$\alpha_{i2}$</span>, while <span>$\alpha_j, j∉\{i1, i2\}$</span> are fixed. An iteration of SMO consists of two steps:</p><p><strong>Selection Step:</strong> Select <span>$i1$</span> and <span>$i2$</span>.</p><ul><li>The search for a good <span>$i2$</span> are implemented in <a href="#SVDD.smo"><code>SVDD.smo</code></a></li><li>There are several heuristics to select <span>$i1$</span> based on the choice for <span>$i2$</span>. These heuristics are implemented in <a href="#SVDD.examineExample!"><code>SVDD.examineExample!</code></a></li></ul><p><strong>Optimization Step:</strong> Solving the reduced Lagrangian for <span>$\alpha_{i1}$</span> and <span>$\alpha_{i2}$</span>.</p><ul><li>Implemented in <a href="#SVDD.takeStep!"><code>SVDD.takeStep!</code></a></li></ul><p>The iterative procedure converges to the global optimum. The following sections give details on both steps.</p><h3><a class="nav-anchor" id="Optimization-Step:-Solving-the-reduced-Lagrangian-1" href="#Optimization-Step:-Solving-the-reduced-Lagrangian-1">Optimization Step: Solving the reduced Lagrangian</a></h3><p>The following describes how to infer the optimal solution for a given <span>$\alpha_{i1}$</span> and <span>$\alpha_{i2}$</span> analytically.</p><p>First, <span>$\alpha_{i1}$</span> and <span>$\alpha_{i2}$</span> can only be changed in a limited range. The reason is that after the optimization step, they still have to obey the constraints of the Lagrangian. From <span>$\sum_i\alpha_i = 1$</span>, one can infer that <span>$Δ = \alpha_{i1} + \alpha_{i2}$</span> remains constant for one optimization step. This is, if we add some value to <span>$\alpha_{i2}$</span>, we must remove the same value from <span>$\alpha_{i1}$</span>. We also know that <span>$\alpha_{i} \geq 0$</span> and <span>$\alpha_{i} \leq C$</span>. From this, one can infer the maximum and minumum value that one can add/substract from <span>$\alpha_{i2}$</span>, i.e., one can calculate the lower and the upper bound:</p><div>\[\begin{aligned}
  L &amp;= max(0, \alpha_{i1} + \alpha_{i2} - C)\\
  H &amp;= min(C, \alpha_{i1} + \alpha_{i2})
\end{aligned}\]</div><p>(Note: This is slightly different to the original SMO, as one does not need to discern between different labels <span>$y_i \in \{1,-1\}$</span>.)</p><p>Second, the optimal value <span>$\alpha^*_{i2}$</span> can be derived analytically by setting the partial derivative of the Lagrangian objective function to 0.</p><div>\[f_{D} = \sum_{i,j} \alpha_i \alpha_j K_{i,j} - \sum_{i}\alpha_{i} K_{i,i} \\
\frac{\delta f_{D}}{\alpha_{i2}} = 0

\iff  \alpha^*_{i2} = \frac{2\Delta(K_{i1,i1} - K_{i1,i2}) + C_1 - C_2 - K_{i1,i1} + K_{i2,i2}}{2K_{i1,i1}+2K_{i2, i2}-4K_{i1, i2}}, \\
\text{where} \ C_k=\alpha_{k}\sum_{j=3}^{N}\alpha_j K_{k,j}\]</div><p>The resulting value is <em>clipped</em> to the feasible interval.</p><pre><code class="language-none">if α*_i2 &gt; H
    α&#39;_i2 = H
elseif α*_i2 &lt; L
    α&#39;_i2 = L
end</code></pre><p>where <code>α&#39;_i2</code> is the updated value of <code>α_i2</code> after the optimization step. It follows that</p><pre><code class="language-none">  α&#39;_i1 = Δ - α&#39;_i2</code></pre><p>To allow the algorithm to converge, one has to decide on a threshold whether the updates to the alpha values has been significant, i.e., if the difference between the old and the new value is above a specified precision. The implementation uses the decision rule from the original SMO [1, p.10], i.e., update alpha values only if</p><div>\[\lvert\alpha_{i2} - \alpha&#39;_{i2} \rvert &gt; \text{opt_precision} * (\alpha_{i2} + \alpha&#39;_{i2} + \text{opt_precision})\]</div><p>where <code>opt_precision</code> is a parameter of the optimization algorithm. This optimization step is implemented in</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SVDD.takeStep!" href="#SVDD.takeStep!"><code>SVDD.takeStep!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">takeStep!(α, i1, i2, K, C, opt_precision)

Take optimization step for i1 and i2 and update α.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/1c8bddf6354010f86344c3ea2485f8878ccbf865/src/solvers/smo_svdd.jl#L6-L10">source</a></section><h3><a class="nav-anchor" id="Selection-Step:-Finding-a-pair-(i1,-i2)-1" href="#Selection-Step:-Finding-a-pair-(i1,-i2)-1">Selection Step: Finding a pair (i1, i2)</a></h3><p>To take an optimization step, one has to select i1 and i2 first. The rationale of SMO is to select indices that are likely to make a large step optimization step. SMO uses heuristics to first select i2, and then select i1 based on it.</p><h5><a class="nav-anchor" id="Selection-of-i2-1" href="#Selection-of-i2-1">Selection of i2</a></h5><p>A minimum of <span>$P$</span> has to obey the <a href="https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions">KKT conditions</a>. The relevant KKT condition here is complementary slackness, i.e.,</p><div>\[  \mu_i g_i(x^*) = 0, \, \forall i\]</div><p>with dual variable <span>$\mu$</span> and inequality conditions <span>$g$</span>. In other words, either the inequality constraint is fulfilled with equality, i.e., <span>$g_i = 0$</span>, or the Lagrange multiplier is zero, i.e., <span>$\mu_i=0$</span>. For SVDD, this translates to</p><div>\[  \begin{aligned}
    &amp;\left\lVert a - \phi(x_i) \right\rVert^2 &lt; R^2 \rightarrow \alpha_i = 0 \\
    &amp;\left\lVert a - \phi(x_i) \right\rVert^2 = R^2 \rightarrow  0 &lt; \alpha_i &lt; C\\
    &amp;\left\lVert a - \phi(x_i) \right\rVert^2 &gt; R^2 \rightarrow \alpha_i = C
 \end{aligned}\]</div><p>See [2] for details. The distance to the decision boundary is <span>$\left\lVert a - \phi(x_i) \right\rVert^2 - R^2$</span> which is negative for observations that lie in the hypershpere.</p><p>So to check for KKT violations, one has to calculate the distance of <span>$\phi(x_i)$</span> from the decision boundary, i.e., the left-hand side of the implications above, and compare it with the the respective <span>$\alpha$</span> value. The check for KKT violations is implemented in</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SVDD.violates_KKT_condition" href="#SVDD.violates_KKT_condition"><code>SVDD.violates_KKT_condition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">violates_KKT_condition(i2, distances_to_decision_boundary, α, C, opt_precision)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/1c8bddf6354010f86344c3ea2485f8878ccbf865/src/solvers/smo_svdd.jl#L65-L68">source</a></section><p><a href="#SVDD.smo"><code>SVDD.smo</code></a> selects <span>$i2$</span> by searching for indices that violate the KKT conditions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SVDD.smo" href="#SVDD.smo"><code>SVDD.smo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">smo(α, K, C, opt_precision, max_iterations)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/1c8bddf6354010f86344c3ea2485f8878ccbf865/src/solvers/smo_svdd.jl#L142-L145">source</a></section><p>This function conducts two tyes of search.</p><p><em>First type:</em> search over the full data set, and randomly selects one of the violating indices.</p><p><em>Second type:</em> restricted search for violations over the subset where <span>$0 &lt;\alpha_i &lt; C$</span>. These variables are the non-bounded support vectors <span>$SV_{nb}$</span>.</p><p>There is one search of the first type, then multiple searches of the second type. After each search, <span>$i2$</span> is selected randomly from one of the violating indices, see</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SVDD.examine_and_update_predictions!" href="#SVDD.examine_and_update_predictions!"><code>SVDD.examine_and_update_predictions!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">examine_and_update_predictions!(α, distances_to_center, distances_to_decision_boundary, R,
    KKT_violations, black_list, K, C, opt_precision)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/1c8bddf6354010f86344c3ea2485f8878ccbf865/src/solvers/smo_svdd.jl#L127-L130">source</a></section><h5><a class="nav-anchor" id="Selection-of-i1-1" href="#Selection-of-i1-1">Selection of i1</a></h5><p>SMO selects <span>$i1$</span> such that the optimization step is as large as possible. The idea for selecting <span>$i1$</span> is as follows. For <span>$\alpha_{i2} &gt; 0$</span> and negative distance to decision boundary, alpha may decrease. So a good <span>$\alpha_{i1}$</span> is one that is likely to increase in the optimization step, i.e., an index where the distance to the decision boundary is positive, and <span>$\alpha_{i1} = 0$</span>. The heuristic SMO selects the <span>$i1$</span> with maximum absolute distance between the distance to the center of <span>$i2$</span> and the distance to the center of some <span>$i1 \in SV_{nb}$</span>. (Note that using the distance to the decision boundary is equivalent to using the distance to the center in this step). This selection heuristic is implemented in</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SVDD.second_choice_heuristic" href="#SVDD.second_choice_heuristic"><code>SVDD.second_choice_heuristic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">second_choice_heuristic(i2, α, distances_to_center, C, opt_precision)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/1c8bddf6354010f86344c3ea2485f8878ccbf865/src/solvers/smo_svdd.jl#L78-L80">source</a></section><p>In some cases, the selected <span>$i1$</span> does not lead to a positive optimization step. In this case, there are two fallback strategies. First, all other indices in <span>$SV_{nb}$</span> are selected, in random order, whether they result in a positive optimization step. Second, if there still is no <span>$i1$</span> that results in a positive optimization step, all remaining indices are selected. If none of the fallback strategies works, <span>$i2$</span> is skipped and added to a blacklist. The fallback strategies are implemented in</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SVDD.examineExample!" href="#SVDD.examineExample!"><code>SVDD.examineExample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">examineExample!(α, i2, distances_to_center, K, C, opt_precision)

The fallback strategies if second choice heuristic returns false follow recommendations in
J. Platt, &quot;Sequential minimal optimization: A fast algorithm for training support vector machines,&quot; 1998.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/1c8bddf6354010f86344c3ea2485f8878ccbf865/src/solvers/smo_svdd.jl#L90-L95">source</a></section><h3><a class="nav-anchor" id="Termination-1" href="#Termination-1">Termination</a></h3><p>If there are no more KKT violations, the algorithm terminates.</p><h3><a class="nav-anchor" id="Further-implementation-details-1" href="#Further-implementation-details-1">Further implementation details</a></h3><p>This section describes some further implementation details.</p><h5><a class="nav-anchor" id="Initialize-alpha-1" href="#Initialize-alpha-1">Initialize alpha</a></h5><p>The vector <span>$\alpha$</span> must be initialized such that it fulfills the constraints of <span>$D$</span>. The implementation uses the initialization strategy proposed in [3], i.e., randomly setting <span>$\frac{1}{C}$</span> indices to <span>$C$</span>. This is implemented in</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SVDD.initialize_alpha" href="#SVDD.initialize_alpha"><code>SVDD.initialize_alpha</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initialize_alpha(data, C)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/1c8bddf6354010f86344c3ea2485f8878ccbf865/src/solvers/smo_svdd.jl#L116-L118">source</a></section><h5><a class="nav-anchor" id="Calculating-Distances-to-Decision-Boundary-1" href="#Calculating-Distances-to-Decision-Boundary-1">Calculating Distances to Decision Boundary</a></h5><p>The distances to the decision boundary are calculated in</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SVDD.calculate_predictions" href="#SVDD.calculate_predictions"><code>SVDD.calculate_predictions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">calculate_predictions(α, K, C, opt_precision)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/1c8bddf6354010f86344c3ea2485f8878ccbf865/src/solvers/smo_svdd.jl#L44-L46">source</a></section><p>In general, to calculate <span>$R$</span>, one can calculate the distance to any non-bounded support vector, i.e., <span>$0 &lt; \alpha_i &lt; C$</span>, as they all lie on the hypershpere. However, this may not always hold. There may be cases where the solution for R is not unique, and different support vectors result in different <span>$R$</span>, in particular in intermediate optimization steps where some <span>$\alpha$</span> values may be non-bounded but violate the KKT conditions. Therefore, <span>$R$</span> is averaged over all non-bounded support vectors. See also [4] for details on non-unique <span>$R$</span> values.</p><h5><a class="nav-anchor" id="SMO-parameters-1" href="#SMO-parameters-1">SMO parameters</a></h5><p>There are two parameters for SMO: <code>opt_precision</code> and <code>max_iterations</code>.</p><p><code>opt_precision</code> influences the convergence. Small <code>opt_precision</code> values require a larger number of iterations until termination.</p><p><code>max_iterations</code> controls the number of times a new <span>$i2$</span> is selected to attempt an optimization step.</p><h2><a class="nav-anchor" id="External-API-1" href="#External-API-1">External API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SVDD.solve!-Tuple{VanillaSVDD,SMOSolver}" href="#SVDD.solve!-Tuple{VanillaSVDD,SMOSolver}"><code>SVDD.solve!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">solve!(model::VanillaSVDD, solver::SMOSolver)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/1c8bddf6354010f86344c3ea2485f8878ccbf865/src/solvers/smo_svdd.jl#L195-L197">source</a></section><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><p>[1] J. Platt, &quot;Sequential minimal optimization: A fast algorithm for training support vector machines,&quot; 1998.</p><p>[2] D. M. J. Tax and R. P. W. Duin, &quot;Support Vector Data Description,&quot;&quot; Mach. Learn., 2004.</p><p>[3] B. Schölkopf, J. C. Platt, J. Shawe-Taylor, A. J. Smola, and R. C. Williamson, &quot;Estimating the support of a high-dimensional distribution,&quot;&quot; Neural Comput., 2001.</p><p>[4] W.-C. Chang, C.-P. Lee, and C.-J. Lin, &quot;A revisit to support vector data description,&quot;Nat. Taiwan Univ., Tech. Rep, 2013.</p><footer><hr/><a class="previous" href="../svdd/"><span class="direction">Previous</span><span class="title">SVDD</span></a></footer></article></body></html>
