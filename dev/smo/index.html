<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SMO · SVDD Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SVDD Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../start/">Getting Started</a></li><li><a class="tocitem" href="../svdd/">SVDD</a></li><li><span class="tocitem">Custom Solvers</span><ul><li class="is-active"><a class="tocitem" href>SMO</a><ul class="internal"><li><a class="tocitem" href="#SVDD-Overview"><span>SVDD Overview</span></a></li><li><a class="tocitem" href="#SMO-for-SVDD"><span>SMO for SVDD</span></a></li><li><a class="tocitem" href="#External-API"><span>External API</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Custom Solvers</a></li><li class="is-active"><a href>SMO</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SMO</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/englhardt/SVDD.jl/blob/master/docs/src/smo.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="smo_doc"><a class="docs-heading-anchor" href="#smo_doc">SMO</a><a id="smo_doc-1"></a><a class="docs-heading-anchor-permalink" href="#smo_doc" title="Permalink"></a></h1><p>Sequential Minimal Optimization (SMO) is a decomposition method to solve quadratic optimization problems with a specific structure. The original SMO algorithm by John C. Platt has been proposed for Support Vector Machines (SVM). There are several modifications for other types of support vector machines. This section describes the implementation of SMO for Support Vector Data Description (SVDD) [2].</p><p>The implementation of SMO for SVDD bases on an adaption of SMO for one-class classification [3]. Therefore, this documentation focuses on the specific adaptions required for SVDD. The following descriptions assume familarity with the basics of SMO [1] and its adaption to one-class SVM [3], and of SVDD [2].</p><h2 id="SVDD-Overview"><a class="docs-heading-anchor" href="#SVDD-Overview">SVDD Overview</a><a id="SVDD-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#SVDD-Overview" title="Permalink"></a></h2><p>SVDD is an optimization problem of the following form.</p><p class="math-container">\[  \begin{aligned}
  P: \ &amp; \underset{R, a, \xi}{\text{minimize}}
  &amp; &amp; R^2 + \sum_i \xi_i  \\
  &amp; \text{subject to}
  &amp; &amp; \left\Vert \Phi(x_{i}) - a \right\Vert^2 \leq R^2 + \xi_i, \; ∀ i \\
  &amp; &amp; &amp; \xi_i \geq 0, \; ∀ i
  \end{aligned}\]</p><p>with radius <span>$R$</span> and center of the hypershpere <span>$a$</span>, a slack variable <span>$\xi$</span>, and a mapping into an implicit feature space <span>$\Phi$</span></p><p>The Lagrangian Dual is:</p><p class="math-container">\[\begin{aligned}
D: \ &amp; \underset{\alpha}{\text{maximize}}
&amp; &amp; \sum_i \alpha_iK_{i,i} - \sum_{i,j}\alpha_i\alpha_j K_{i,j} \\
&amp; \text{subject to}
&amp; &amp; \sum_i \alpha_i = 1 \\
&amp; &amp; &amp; 0 \leq \alpha_i \leq C, \; ∀ i \\
\end{aligned}\]</p><p>where <span>$\alpha$</span> are the Lagrange multipliers, and <span>$K_{i,j} = \langle {\Phi(x_i),\Phi{x_j}} \rangle$</span> the inner product in the implicit feature space. Solving the Lagrangian gives an optimal <span>$α$</span>.</p><h2 id="SMO-for-SVDD"><a class="docs-heading-anchor" href="#SMO-for-SVDD">SMO for SVDD</a><a id="SMO-for-SVDD-1"></a><a class="docs-heading-anchor-permalink" href="#SMO-for-SVDD" title="Permalink"></a></h2><p>The basic idea of SMO is to solve reduced versions of the Lagrangian iteratively. In each iteration, the reduced version of the Lagrangian consists of only two decision variables, i.e., <span>$\alpha_{i1}$</span> and <span>$\alpha_{i2}$</span>, while <span>$\alpha_j, j∉\{i1, i2\}$</span> are fixed. An iteration of SMO consists of two steps:</p><p><strong>Selection Step:</strong> Select <span>$i1$</span> and <span>$i2$</span>.</p><ul><li>The search for a good <span>$i2$</span> are implemented in <a href="#SVDD.smo"><code>SVDD.smo</code></a></li><li>There are several heuristics to select <span>$i1$</span> based on the choice for <span>$i2$</span>. These heuristics are implemented in <a href="#SVDD.examineExample!"><code>SVDD.examineExample!</code></a></li></ul><p><strong>Optimization Step:</strong> Solving the reduced Lagrangian for <span>$\alpha_{i1}$</span> and <span>$\alpha_{i2}$</span>.</p><ul><li>Implemented in <a href="#SVDD.takeStep!"><code>SVDD.takeStep!</code></a></li></ul><p>The iterative procedure converges to the global optimum. The following sections give details on both steps.</p><h3 id="Optimization-Step:-Solving-the-reduced-Lagrangian"><a class="docs-heading-anchor" href="#Optimization-Step:-Solving-the-reduced-Lagrangian">Optimization Step: Solving the reduced Lagrangian</a><a id="Optimization-Step:-Solving-the-reduced-Lagrangian-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Step:-Solving-the-reduced-Lagrangian" title="Permalink"></a></h3><p>The following describes how to infer the optimal solution for a given <span>$\alpha_{i1}$</span> and <span>$\alpha_{i2}$</span> analytically.</p><p>First, <span>$\alpha_{i1}$</span> and <span>$\alpha_{i2}$</span> can only be changed in a limited range. The reason is that after the optimization step, they still have to obey the constraints of the Lagrangian. From <span>$\sum_i\alpha_i = 1$</span>, one can infer that <span>$Δ = \alpha_{i1} + \alpha_{i2}$</span> remains constant for one optimization step. This is, if we add some value to <span>$\alpha_{i2}$</span>, we must remove the same value from <span>$\alpha_{i1}$</span>. We also know that <span>$\alpha_{i} \geq 0$</span> and <span>$\alpha_{i} \leq C$</span>. From this, one can infer the maximum and minumum value that one can add/substract from <span>$\alpha_{i2}$</span>, i.e., one can calculate the lower and the upper bound:</p><p class="math-container">\[\begin{aligned}
  L &amp;= max(0, \alpha_{i1} + \alpha_{i2} - C)\\
  H &amp;= min(C, \alpha_{i1} + \alpha_{i2})
\end{aligned}\]</p><p>(Note: This is slightly different to the original SMO, as one does not need to discern between different labels <span>$y_i \in \{1,-1\}$</span>.)</p><p>Second, the optimal value <span>$\alpha^*_{i2}$</span> can be derived analytically by setting the partial derivative of the Lagrangian objective function to 0.</p><p class="math-container">\[f_{D} = \sum_{i,j} \alpha_i \alpha_j K_{i,j} - \sum_{i}\alpha_{i} K_{i,i} \\
\frac{\delta f_{D}}{\alpha_{i2}} = 0

\iff  \alpha^*_{i2} = \frac{2\Delta(K_{i1,i1} - K_{i1,i2}) + C_1 - C_2 - K_{i1,i1} + K_{i2,i2}}{2K_{i1,i1}+2K_{i2, i2}-4K_{i1, i2}}, \\
\text{where} \ C_k=\alpha_{k}\sum_{j=3}^{N}\alpha_j K_{k,j}\]</p><p>The resulting value is <em>clipped</em> to the feasible interval.</p><pre><code class="nohighlight hljs">if α*_i2 &gt; H
    α&#39;_i2 = H
elseif α*_i2 &lt; L
    α&#39;_i2 = L
end</code></pre><p>where <code>α&#39;_i2</code> is the updated value of <code>α_i2</code> after the optimization step. It follows that</p><pre><code class="nohighlight hljs">  α&#39;_i1 = Δ - α&#39;_i2</code></pre><p>To allow the algorithm to converge, one has to decide on a threshold whether the updates to the alpha values has been significant, i.e., if the difference between the old and the new value is above a specified precision. The implementation uses the decision rule from the original SMO [1, p.10], i.e., update alpha values only if</p><p class="math-container">\[\lvert\alpha_{i2} - \alpha&#39;_{i2} \rvert &gt; \text{opt_precision} * (\alpha_{i2} + \alpha&#39;_{i2} + \text{opt_precision})\]</p><p>where <code>opt_precision</code> is a parameter of the optimization algorithm. This optimization step is implemented in</p><article class="docstring"><header><a class="docstring-binding" id="SVDD.takeStep!" href="#SVDD.takeStep!"><code>SVDD.takeStep!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">takeStep!(α, i1, i2, K, C, opt_precision)

Take optimization step for i1 and i2 and update α.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/48126e45b8773dd5cd89b589a6647c34900b992a/src/solvers/smo_svdd.jl#L6-L10">source</a></section></article><h3 id="Selection-Step:-Finding-a-pair-(i1,-i2)"><a class="docs-heading-anchor" href="#Selection-Step:-Finding-a-pair-(i1,-i2)">Selection Step: Finding a pair (i1, i2)</a><a id="Selection-Step:-Finding-a-pair-(i1,-i2)-1"></a><a class="docs-heading-anchor-permalink" href="#Selection-Step:-Finding-a-pair-(i1,-i2)" title="Permalink"></a></h3><p>To take an optimization step, one has to select i1 and i2 first. The rationale of SMO is to select indices that are likely to make a large step optimization step. SMO uses heuristics to first select i2, and then select i1 based on it.</p><h5 id="Selection-of-i2"><a class="docs-heading-anchor" href="#Selection-of-i2">Selection of i2</a><a id="Selection-of-i2-1"></a><a class="docs-heading-anchor-permalink" href="#Selection-of-i2" title="Permalink"></a></h5><p>A minimum of <span>$P$</span> has to obey the <a href="https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions">KKT conditions</a>. The relevant KKT condition here is complementary slackness, i.e.,</p><p class="math-container">\[  \mu_i g_i(x^*) = 0, \, \forall i\]</p><p>with dual variable <span>$\mu$</span> and inequality conditions <span>$g$</span>. In other words, either the inequality constraint is fulfilled with equality, i.e., <span>$g_i = 0$</span>, or the Lagrange multiplier is zero, i.e., <span>$\mu_i=0$</span>. For SVDD, this translates to</p><p class="math-container">\[  \begin{aligned}
    &amp;\left\lVert a - \phi(x_i) \right\rVert^2 &lt; R^2 \rightarrow \alpha_i = 0 \\
    &amp;\left\lVert a - \phi(x_i) \right\rVert^2 = R^2 \rightarrow  0 &lt; \alpha_i &lt; C\\
    &amp;\left\lVert a - \phi(x_i) \right\rVert^2 &gt; R^2 \rightarrow \alpha_i = C
 \end{aligned}\]</p><p>See [2] for details. The distance to the decision boundary is <span>$\left\lVert a - \phi(x_i) \right\rVert^2 - R^2$</span> which is negative for observations that lie in the hypershpere.</p><p>So to check for KKT violations, one has to calculate the distance of <span>$\phi(x_i)$</span> from the decision boundary, i.e., the left-hand side of the implications above, and compare it with the the respective <span>$\alpha$</span> value. The check for KKT violations is implemented in</p><article class="docstring"><header><a class="docstring-binding" id="SVDD.violates_KKT_condition" href="#SVDD.violates_KKT_condition"><code>SVDD.violates_KKT_condition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">violates_KKT_condition(i2, distances_to_decision_boundary, α, C, opt_precision)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/48126e45b8773dd5cd89b589a6647c34900b992a/src/solvers/smo_svdd.jl#L65-L68">source</a></section></article><p><a href="#SVDD.smo"><code>SVDD.smo</code></a> selects <span>$i2$</span> by searching for indices that violate the KKT conditions.</p><article class="docstring"><header><a class="docstring-binding" id="SVDD.smo" href="#SVDD.smo"><code>SVDD.smo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smo(α, K, C, opt_precision, max_iterations)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/48126e45b8773dd5cd89b589a6647c34900b992a/src/solvers/smo_svdd.jl#L142-L145">source</a></section></article><p>This function conducts two tyes of search.</p><p><em>First type:</em> search over the full data set, and randomly selects one of the violating indices.</p><p><em>Second type:</em> restricted search for violations over the subset where <span>$0 &lt;\alpha_i &lt; C$</span>. These variables are the non-bounded support vectors <span>$SV_{nb}$</span>.</p><p>There is one search of the first type, then multiple searches of the second type. After each search, <span>$i2$</span> is selected randomly from one of the violating indices, see</p><article class="docstring"><header><a class="docstring-binding" id="SVDD.examine_and_update_predictions!" href="#SVDD.examine_and_update_predictions!"><code>SVDD.examine_and_update_predictions!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">examine_and_update_predictions!(α, distances_to_center, distances_to_decision_boundary, R,
    KKT_violations, black_list, K, C, opt_precision)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/48126e45b8773dd5cd89b589a6647c34900b992a/src/solvers/smo_svdd.jl#L127-L130">source</a></section></article><h5 id="Selection-of-i1"><a class="docs-heading-anchor" href="#Selection-of-i1">Selection of i1</a><a id="Selection-of-i1-1"></a><a class="docs-heading-anchor-permalink" href="#Selection-of-i1" title="Permalink"></a></h5><p>SMO selects <span>$i1$</span> such that the optimization step is as large as possible. The idea for selecting <span>$i1$</span> is as follows. For <span>$\alpha_{i2} &gt; 0$</span> and negative distance to decision boundary, alpha may decrease. So a good <span>$\alpha_{i1}$</span> is one that is likely to increase in the optimization step, i.e., an index where the distance to the decision boundary is positive, and <span>$\alpha_{i1} = 0$</span>. The heuristic SMO selects the <span>$i1$</span> with maximum absolute distance between the distance to the center of <span>$i2$</span> and the distance to the center of some <span>$i1 \in SV_{nb}$</span>. (Note that using the distance to the decision boundary is equivalent to using the distance to the center in this step). This selection heuristic is implemented in</p><article class="docstring"><header><a class="docstring-binding" id="SVDD.second_choice_heuristic" href="#SVDD.second_choice_heuristic"><code>SVDD.second_choice_heuristic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">second_choice_heuristic(i2, α, distances_to_center, C, opt_precision)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/48126e45b8773dd5cd89b589a6647c34900b992a/src/solvers/smo_svdd.jl#L78-L80">source</a></section></article><p>In some cases, the selected <span>$i1$</span> does not lead to a positive optimization step. In this case, there are two fallback strategies. First, all other indices in <span>$SV_{nb}$</span> are selected, in random order, whether they result in a positive optimization step. Second, if there still is no <span>$i1$</span> that results in a positive optimization step, all remaining indices are selected. If none of the fallback strategies works, <span>$i2$</span> is skipped and added to a blacklist. The fallback strategies are implemented in</p><article class="docstring"><header><a class="docstring-binding" id="SVDD.examineExample!" href="#SVDD.examineExample!"><code>SVDD.examineExample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">examineExample!(α, i2, distances_to_center, K, C, opt_precision)

The fallback strategies if second choice heuristic returns false follow recommendations in
J. Platt, &quot;Sequential minimal optimization: A fast algorithm for training support vector machines,&quot; 1998.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/48126e45b8773dd5cd89b589a6647c34900b992a/src/solvers/smo_svdd.jl#L90-L95">source</a></section></article><h3 id="Termination"><a class="docs-heading-anchor" href="#Termination">Termination</a><a id="Termination-1"></a><a class="docs-heading-anchor-permalink" href="#Termination" title="Permalink"></a></h3><p>If there are no more KKT violations, the algorithm terminates.</p><h3 id="Further-implementation-details"><a class="docs-heading-anchor" href="#Further-implementation-details">Further implementation details</a><a id="Further-implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Further-implementation-details" title="Permalink"></a></h3><p>This section describes some further implementation details.</p><h5 id="Initialize-alpha"><a class="docs-heading-anchor" href="#Initialize-alpha">Initialize alpha</a><a id="Initialize-alpha-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-alpha" title="Permalink"></a></h5><p>The vector <span>$\alpha$</span> must be initialized such that it fulfills the constraints of <span>$D$</span>. The implementation uses the initialization strategy proposed in [3], i.e., randomly setting <span>$\frac{1}{C}$</span> indices to <span>$C$</span>. This is implemented in</p><article class="docstring"><header><a class="docstring-binding" id="SVDD.initialize_alpha" href="#SVDD.initialize_alpha"><code>SVDD.initialize_alpha</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialize_alpha(data, C)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/48126e45b8773dd5cd89b589a6647c34900b992a/src/solvers/smo_svdd.jl#L116-L118">source</a></section></article><h5 id="Calculating-Distances-to-Decision-Boundary"><a class="docs-heading-anchor" href="#Calculating-Distances-to-Decision-Boundary">Calculating Distances to Decision Boundary</a><a id="Calculating-Distances-to-Decision-Boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-Distances-to-Decision-Boundary" title="Permalink"></a></h5><p>The distances to the decision boundary are calculated in</p><article class="docstring"><header><a class="docstring-binding" id="SVDD.calculate_predictions" href="#SVDD.calculate_predictions"><code>SVDD.calculate_predictions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calculate_predictions(α, K, C, opt_precision)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/48126e45b8773dd5cd89b589a6647c34900b992a/src/solvers/smo_svdd.jl#L44-L46">source</a></section></article><p>In general, to calculate <span>$R$</span>, one can calculate the distance to any non-bounded support vector, i.e., <span>$0 &lt; \alpha_i &lt; C$</span>, as they all lie on the hypershpere. However, this may not always hold. There may be cases where the solution for R is not unique, and different support vectors result in different <span>$R$</span>, in particular in intermediate optimization steps where some <span>$\alpha$</span> values may be non-bounded but violate the KKT conditions. Therefore, <span>$R$</span> is averaged over all non-bounded support vectors. See also [4] for details on non-unique <span>$R$</span> values.</p><h5 id="SMO-parameters"><a class="docs-heading-anchor" href="#SMO-parameters">SMO parameters</a><a id="SMO-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#SMO-parameters" title="Permalink"></a></h5><p>There are two parameters for SMO: <code>opt_precision</code> and <code>max_iterations</code>.</p><p><code>opt_precision</code> influences the convergence. Small <code>opt_precision</code> values require a larger number of iterations until termination.</p><p><code>max_iterations</code> controls the number of times a new <span>$i2$</span> is selected to attempt an optimization step.</p><h2 id="External-API"><a class="docs-heading-anchor" href="#External-API">External API</a><a id="External-API-1"></a><a class="docs-heading-anchor-permalink" href="#External-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SVDD.solve!-Tuple{VanillaSVDD, SMOSolver}" href="#SVDD.solve!-Tuple{VanillaSVDD, SMOSolver}"><code>SVDD.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(model::VanillaSVDD, solver::SMOSolver)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/englhardt/SVDD.jl/blob/48126e45b8773dd5cd89b589a6647c34900b992a/src/solvers/smo_svdd.jl#L195-L197">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] J. Platt, &quot;Sequential minimal optimization: A fast algorithm for training support vector machines,&quot; 1998.</p><p>[2] D. M. J. Tax and R. P. W. Duin, &quot;Support Vector Data Description,&quot;&quot; Mach. Learn., 2004.</p><p>[3] B. Schölkopf, J. C. Platt, J. Shawe-Taylor, A. J. Smola, and R. C. Williamson, &quot;Estimating the support of a high-dimensional distribution,&quot;&quot; Neural Comput., 2001.</p><p>[4] W.-C. Chang, C.-P. Lee, and C.-J. Lin, &quot;A revisit to support vector data description,&quot;Nat. Taiwan Univ., Tech. Rep, 2013.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../svdd/">« SVDD</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.11 on <span class="colophon-date" title="Sunday 16 January 2022 21:57">Sunday 16 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
